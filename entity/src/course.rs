//! SeaORM Entity. Generated by sea-orm-codegen 0.8.0

use sea_orm::entity::prelude::*;
use crate::review;
use serde::{Deserialize, Serialize};
use sea_orm::ModelTrait;
use utoipa::ToSchema;
use crate::review::GetReview;

#[derive(Clone, Debug, PartialEq, Deserialize, Serialize, DeriveEntityModel, ToSchema)]
#[sea_orm(table_name = "course")]
pub struct Model {
    #[sea_orm(primary_key)]
    pub id: i32,
    #[sea_orm(column_type = "Custom(\"LONGTEXT\".to_owned())")]
    pub name: String,
    #[sea_orm(column_type = "Custom(\"LONGTEXT\".to_owned())")]
    pub code: String,
    #[sea_orm(column_type = "Custom(\"LONGTEXT\".to_owned())")]
    pub code_id: String,
    pub credit: f64,
    #[sea_orm(column_type = "Custom(\"LONGTEXT\".to_owned())")]
    pub department: String,
    #[sea_orm(column_type = "Custom(\"LONGTEXT\".to_owned())")]
    pub campus_name: String,
    #[sea_orm(column_type = "Custom(\"LONGTEXT\".to_owned())")]
    pub teachers: String,
    pub max_student: i32,
    pub week_hour: i32,
    pub year: i32,
    pub semester: i32,
}

#[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]
pub enum Relation {
    #[sea_orm(has_many = "super::review::Entity")]
    Review,
    #[sea_orm(has_many = "super::coursegroup::Entity")]
    Coursegroup,
}

impl Related<super::review::Entity> for Entity {
    fn to() -> RelationDef {
        super::course_review::Relation::Review.def()
    }
    fn via() -> Option<RelationDef> {
        Some(super::course_review::Relation::Course.def().rev())
    }
}

impl Related<super::coursegroup::Entity> for Entity {
    fn to() -> RelationDef {
        super::coursegroup_course::Relation::Coursegroup.def()
    }
    fn via() -> Option<RelationDef> {
        Some(super::coursegroup_course::Relation::Course.def().rev())
    }
}

impl From<Model> for GetSingleCourse {
    fn from(model: Model) -> Self {
        GetSingleCourse {
            id: model.id,
            name: model.name,
            code: model.code,
            code_id: model.code_id,
            credit: model.credit,
            department: model.department,
            campus_name: model.campus_name,
            teachers: model.teachers,
            max_student: model.max_student,
            week_hour: model.week_hour,
            year: model.year,
            semester: model.semester,
            review_list: vec![],
        }
    }
}

impl GetSingleCourse {
    pub async fn load(model: Model, db: &DatabaseConnection, user_id: i32) -> Result<Self, DbErr> {
        let review_raw_list: Vec<review::Model> = model.find_related(review::Entity).all(db).await?;
        let mut course: Self = model.into();
        let mut review_list: Vec<GetReview> = vec![];
        for review in review_raw_list {
            review_list.push(GetReview::new(review, user_id));
        }
        course.review_list = review_list;
        Ok(course)
    }
}

#[derive(Debug, Clone, Deserialize, Serialize, ToSchema)]
pub struct GetSingleCourse {
    pub id: i32,
    pub name: String,
    pub code: String,
    pub code_id: String,
    pub credit: f64,
    pub department: String,
    pub campus_name: String,
    pub teachers: String,
    pub max_student: i32,
    pub week_hour: i32,
    pub year: i32,
    pub semester: i32,
    pub review_list: Vec<GetReview>,
}

#[derive(Debug, Clone, Deserialize, Serialize, DeriveIntoActiveModel, ToSchema)]
pub struct NewCourse {
    pub name: String,
    pub code: String,
    pub code_id: String,
    pub credit: f64,
    pub department: String,
    pub campus_name: String,
    pub teachers: String,
    pub max_student: i32,
    pub week_hour: i32,
    pub year: i32,
    pub semester: i32,
}

impl ActiveModelBehavior for ActiveModel {}
