//! SeaORM Entity. Generated by sea-orm-codegen 0.8.0

use sea_orm::entity::prelude::*;
use crate::course::{GetSingleCourse, NewCourse};
use serde::{Deserialize, Serialize};
use utoipa::ToSchema;
use crate::course;

#[derive(Clone, Debug, PartialEq, Deserialize, Serialize, DeriveEntityModel, ToSchema)]
#[sea_orm(table_name = "coursegroup")]
pub struct Model {
    #[sea_orm(primary_key)]
    pub id: i32,
    #[sea_orm(column_type = "custom(\"LONGTEXT\")")]
    pub name: String,
    #[sea_orm(column_type = "custom(\"LONGTEXT\")")]
    pub code: String,
    #[sea_orm(column_type = "custom(\"LONGTEXT\")")]
    pub department: String,
    #[sea_orm(column_type = "custom(\"LONGTEXT\")")]
    pub campus_name: String,
}

#[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]
pub enum Relation {
    #[sea_orm(has_many = "super::course::Entity")]
    Course,
}

impl Related<course::Entity> for Entity {
    fn to() -> RelationDef {
        Relation::Course.def()
    }
}

impl From<Model> for GetSingleCourseGroup {
    fn from(model: Model) -> Self {
        GetSingleCourseGroup {
            id: model.id,
            name: model.name,
            code: model.code,
            department: model.department,
            campus_name: model.campus_name,
            course_list: vec![],
        }
    }
}

#[derive(Debug, Clone, Deserialize, Serialize, ToSchema)]
pub struct GetSingleCourseGroup {
    pub id: i32,
    pub name: String,
    pub code: String,
    pub department: String,
    pub campus_name: String,
    pub course_list: Vec<GetSingleCourse>,
}

impl GetSingleCourseGroup {
    pub fn new(model: Model, course_list: Vec<GetSingleCourse>) -> GetSingleCourseGroup {
        let mut group: GetSingleCourseGroup = model.into();
        group.course_list = course_list;
        group
    }
}

impl From<Model> for GetMultiCourseGroup {
    fn from(model: Model) -> Self {
        GetMultiCourseGroup {
            id: model.id,
            name: model.name,
            code: model.code,
            department: model.department,
            campus_name: model.campus_name,
            course_list: vec![],
        }
    }
}

#[derive(Debug, Clone, Deserialize, Serialize, ToSchema)]
pub struct GetMultiCourseGroup {
    pub id: i32,
    pub name: String,
    pub code: String,
    pub department: String,
    pub campus_name: String,
    pub course_list: Vec<course::Model>,
}

impl GetMultiCourseGroup {
    pub fn new(model: Model, course_list: Vec<course::Model>) -> GetMultiCourseGroup {
        let mut group: GetMultiCourseGroup = model.into();
        group.course_list = course_list;
        group
    }
}

impl From<NewCourse> for NewCourseGroup {
    fn from(course: NewCourse) -> Self {
        NewCourseGroup {
            name: course.name,
            code: course.code,
            department: course.department,
            campus_name: course.campus_name,
        }
    }
}

#[derive(Debug, Clone, Deserialize, Serialize, DeriveIntoActiveModel, ToSchema)]
pub struct NewCourseGroup {
    pub name: String,
    pub code: String,
    pub department: String,
    pub campus_name: String,
}

impl ActiveModelBehavior for ActiveModel {}
